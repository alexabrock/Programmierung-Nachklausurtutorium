\section{Binäre Suche}

\begin{frame}[fragile]
\frametitle{Binäre Suche}
Wir stellen uns vor wir haben ein sortiertes Array an Zahlen.
\begin{lstlisting}
    int[] myArray = {1,4,5,6,8,8,10};
\end{lstlisting}
Wie finden wir nun raus, an welchem Index die Zahl 5 liegt?
\end{frame}

\begin{frame}[fragile]
\frametitle{Binäre Suche - Funktionsweise}
\begin{enumerate}
    \item Wir schauen uns das mittlere Element an.
    \item Ist dieses Element die gesuchte Zahl, sind wir fertig.
    \item Ist die gesuchte Zahl kleiner als das mittlere Element, suchen wir im linken Teil des Arrays weiter.
    \item Ist die gesuchte Zahl größer als das mittlere Element, suchen wir im rechten Teil des Arrays weiter.
    \item Wir wiederholen die Schritte 1-4, bis wir die Zahl gefunden haben oder der Suchbereich leer ist.
\end{enumerate}

\end{frame}

\begin{frame}[fragile]
\frametitle{Binäre Suche - Beispiel}
\begin{lstlisting}
    int[] myArray = {1,4,5,6,8,8,10};
    int gesuchteZahl = 5;
\end{lstlisting}
\begin{enumerate}
    \item Mittleres Element: 6 (Index 3)
    \item 5 < 6, also suchen wir im linken Teil: \{1, 4, 5\}
    \item Mittleres Element: 4 (Index 1)
    \item 5 > 4, also suchen wir im rechten Teil: \{5\}
    \item Mittleres Element: 5 (Index 2)
    \item Zahl gefunden! Index: 2
\end{enumerate}
\end{frame}

\begin{frame}[fragile]
\frametitle{Binäre Suche Aufgaben}
\begin{itemize}
    \item wie viele Iterationen benötigen wir im schlechtesten möglichen Fall?
    \item Implementieren Sie Binäre Suche
    \item für schnelle: können sie das auch Rekursiv implementieren?
\end{itemize}  
\end{frame}