\section{Hashing}
\begin{frame}{Was ist Hashing?}
  \begin{itemize}
    \item Hashing ist ein Verfahren, um Daten schnell zu finden.
    \item Es wandelt einen Schlüssel (z.B. einen String) in einen Index um.
    \item Dieser Index zeigt auf einen Speicherort (Bucket) in einer Hashtabelle.
    \item Ziel: Schneller Zugriff auf Daten (im Idealfall O(1)).
  \end{itemize}
\end{frame}

\begin{frame}{Hashfunktionen}
  \begin{itemize}
    \item Eine Hashfunktion $h(k)$ nimmt einen Schlüssel $k$ und gibt einen Index zurück.
    \item Gute Hashfunktionen verteilen Schlüssel gleichmäßig auf die Buckets.
    \item Beispiele:
    \begin{itemize}
      \item Modulo-Division: $h(k) = k \mod m$ (wobei $m$ die Größe der Hashtabelle ist).
      \item Multiplikationsmethode.
      \item Universelles Hashing.
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{Kollisionen}
  \begin{itemize}
    \item Kollision: Zwei Schlüssel werden auf denselben Bucket abgebildet.
    \item Kollisionen sind unvermeidbar, wenn die Anzahl der Schlüssel größer ist als die Anzahl der Buckets.
    \item Lösungsstrategien:
    \begin{itemize}
      \item Verkettung (Chaining): Buckets sind Listen von Schlüsseln.
      \item Offene Adressierung (Open Addressing): Suche nach einem anderen freien Bucket.
      \begin{itemize}
        \item Lineares Sondieren (Linear Probing).
        \item Quadratisches Sondieren (Quadratic Probing).
        \item Doppeltes Hashing (Double Hashing).
      \end{itemize}
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{Verkettung - Chaining}
  \begin{itemize}
    \item Jeder Bucket ist eine verkettete Liste.
    \item Bei einer Kollision wird der neue Schlüssel am Anfang oder Ende der Liste eingefügt.
    \item Suche: Berechne den Hashwert, durchsuche die entsprechende Liste.
    \item Einfügen und Löschen sind relativ einfach.
  \end{itemize}
\end{frame}

\begin{frame}{Sondierung - Linear}
  \begin{itemize}
    \item Bei einer Kollision wird der nächste freie Bucket gesucht.
    \item Lineares Sondieren: Suche linear nach dem nächsten freien Bucket.
    \item Clustering-Problem: Lange Ketten von belegten Buckets können entstehen.
  \end{itemize}
\end{frame}

\begin{frame}{Sondierung Quadratisch}
  \begin{itemize}
    \item Bei einer Kollision wird der nächste freie Bucket gesucht.
    \item Quadratisch Sondieren: Suche mit x*x nach dem nächsten freien Bucket.
    \item Clustering-Problem: Lange Ketten von belegten Buckets können entstehen.
  \end{itemize}
\end{frame}

\begin{frame}{Anwendungen von Hashing}
  \begin{itemize}
    \item Hashtabellen (Dictionaries, Maps).
    \item Caching.
    \item Kryptographie (Hashfunktionen für Passwörter, digitale Signaturen).
    \item Datenintegrität (Prüfsummen).
    \item Duplikaterkennung.
  \end{itemize}
\end{frame}

\begin{frame}{Zusammenfassung}
  \begin{itemize}
    \item Hashing ist ein wichtiges Verfahren für schnellen Datenzugriff.
    \item Hashfunktionen und Kollisionsstrategien sind entscheidend für die Effizienz.
    \item Hashing hat viele Anwendungen in der Informatik.
  \end{itemize}
\end{frame}

\begin{frame}{Aufgabe 1: Hashfunktion}
  Gegeben sei eine Hashtabelle der Größe 10 und die Hashfunktion $h(k) = k \mod 10$.
  \begin{enumerate}
    \item Berechnen Sie die Hashwerte für die Schlüssel 17, 25, 38, 42, 59.
    \item Zeichnen Sie die Hashtabelle nach dem Einfügen der Schlüssel unter Verwendung von Verkettung (Chaining).
  \end{enumerate}
\end{frame}

\begin{frame}{Aufgabe 2: Lineares Sondieren}
  Gegeben sei eine Hashtabelle der Größe 7 und die Hashfunktion $h(k) = k \mod 7$.
  \begin{enumerate}
    \item Fügen Sie die Schlüssel 12, 19, 26, 33, 40 in die Hashtabelle ein, indem Sie lineares Sondieren verwenden.
    \item Zeichnen Sie die resultierende Hashtabelle.
  \end{enumerate}
\end{frame}

\begin{frame}{Aufgabe 3: Quadratisches Sondieren}
    Gegeben sei eine Hashtabelle der Größe 11 und die Hashfunktion $h(k) = k \mod 11$.
    \begin{enumerate}
        \item Fügen Sie die Schlüssel 14, 25, 36, 47, 58 in die Hashtabelle ein, indem Sie quadratisches Sondieren verwenden. Verwenden Sie die Sondierungsfunktion $h(k) + i^2$, wobei $i = 0, 1, 2, \dots$.
        \item Zeichnen Sie die resultierende Hashtabelle.
    \end{enumerate}
\end{frame}
\begin{frame}{Aufgabe 4: Hashfunktion entwerfen}
  Entwerfen Sie eine Hashfunktion für Strings, die aus Kleinbuchstaben bestehen. Die Hashfunktion sollte die Schlüssel gleichmäßig auf eine Hashtabelle der Größe 26 verteilen.
\end{frame}