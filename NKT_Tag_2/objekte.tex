\section{Objekte und Klassen}

\subsection{Klassen}
\begin{frame}[fragile]
\frametitle{Klassen}
\begin{itemize}
    \item Eine Klasse kann erstellt werden
    \item Die erstellte Klasse wird Objekt genannt
    \item Welche Methoden auf dem Objekt aufgerufen werden können, steht in der Klasse.\newline Klasse $\rightarrow$ Bauplan für Objekt
    \item Es kann nur EINE Klasse mit dem Namen X geben, jedoch unendlich viele Objekte der Klasse X
    \item Alle Klassen erben von der Klasse Object (Vererbung kommt später)
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Methoden in Klassen}
\begin{itemize}
    \item Wollen wir ein Objekt einer Klasse erstellen benutzen wir das Schlüsselwort "new". (Deswegen bitte keine variablen "new" nennen!)
    \item Falls wir keinen Konstruktor selbst schreiben, existiert Default Konstuktor
    \item Da jede Klasse von Object erbt, hat auch jedes Objekt eine toString() Methode
    \item Methodennamen Werden im UpperCamelCase benannt
\end{itemize}
Wie müsste die Person Klasse aussehen, damit folgendes funktioniert?
\begin{lstlisting}
    Person p1 = new Person();
    Person p2 = new Person("Superman");
    System.out.println(p1.toString() + "," + p2.toString());
    //Ausgabe soll "Kein Name,Superman" sein
\end{lstlisting}

\end{frame}

\begin{frame}[fragile]
\frametitle{Klassen}
\begin{lstlisting}
    public class Person {
        String name = "Kein Name";
        public Person(){}
        public Person(String name){
            this.name = name;
        }
        @Override
        public String toString(){
            return name;
        }
    }
\end{lstlisting}
\end{frame}

\subsection{Überladen von Methoden}
\begin{frame}[fragile]
\frametitle{Methoden Überladen}
In Java können wir Methoden überladen. Dies haben wir bereits in der Person Klasse getan. Der Konstruktor existiert zwei mal. Einmal als Default Konstruktor und einmal als Konstruktor der einen Namen für die Person entgegen nimmt und diesen Speichert. Überladen ist sehr hilfreich:
\begin{lstlisting}
    public int sum(int a, int b) {
        return a + b;
    }

    public double sum(double a, double b) {
        return a + b;
    }
\end{lstlisting}
Nun können wir die Methode sum mit int wie auch mit double verwenden.
\end{frame}

\subsection{Überschreiben von Methoden}
\begin{frame}[fragile]
\frametitle{Überschreiben von Methoden}
Das Überschreiben von Methoden wirft im Gegensatz zum Überladen die alte Methode weg. Es existieren also nur Methoden, die nicht überschrieben wurden.
In unserem Person Beispiel haben wir die toString() Methode, die wir von Object geerbt haben, überschrieben. Wenn wir nun auf den Person Objekten die toString() Methode aufrufen wird nun unsere neue Methode genutzt, da die Alte überschrieben ist.
\begin{lstlisting}
    @Override
    public String toString(){
        return name;
    }
\end{lstlisting}\footnote{@Override Annotation nicht nötig, dennoch sinnvoll}
Was wäre Ausgegeben worden, wenn wir die toString() Methode nicht überschrieben hätten?
\end{frame}

\subsection{String Klasse}
\begin{frame}[fragile]
\frametitle{Methoden der String Klasse}
Ein Beispiel für eine bereits bestehende Klasse ist die String Klasse.
\begin{lstlisting}
    String msg = "funnymsg,          irgendwas";
    String msgBig = msg.toUpperCase();
    String[] msgSplit = msg.split(",");
    String msgTrim = msgSplit[1].trim();
\end{lstlisting}
Da ein String ein Objekt ist, also kein Primitiver Datentyp können wir Strings nicht mit == vergleichen. Damit vergleichen wir nur ob die Referez die selbe ist, oder nicht. Wie vergleichen wir nun also Strings?
\begin{lstlisting}
    String a = "Hallo";
    String b = "Welt";
    System.out.println(a.equals(b));
\end{lstlisting}
\end{frame}