\section{Stack}

\subsection{Heap und Stack}
\begin{frame}[fragile]
	\frametitle{Heap und Stack}
	Wo werden eigentlich die Daten gespeichert?
	\begin{itemize}
		\item Stack
		\item Heap
	\end{itemize}
\end{frame}
\subsection{Stack}
\begin{frame}[fragile]
	\frametitle{Stack}
	Auf dem Stack Speichern wir primitive Datentypen und Referenzen. Auch Rücksprungadressen etc. (siehe Rechenarchitektur).
	\begin{itemize}
		\item float
		\item int
		\item double
		\item boolean
		\item char
	\end{itemize}
	Der Stack ist schneller erreichbar als der Heap. Dafür aber deutlich kleiner.
\end{frame}

\begin{frame}[fragile]
	\frametitle{Stack - Zugriff}
    \includegraphics[height=0.4 \textwidth]{images/Stack_LIFO.png}
\textbf{LIFO - Last In first Out}

\end{frame}


\subsection{Heap}
\begin{frame}[fragile]
	\frametitle{Heap}
	Auf dem Heap Speichern wir Objekte.
	\begin{itemize}
		\item Arrays
		\item String
		\item Integer
		\item Double
		\item Person
		\item eigene Klassen
	\end{itemize}
	Der Heap ist im Gegensatz zum Stack viel größer. Dafür aber langsamer.
\end{frame}

\begin{frame}[fragile]
	\frametitle{Heap}	
	\includegraphics[height=0.7\textheight]{images/stack_variablen.png}
\end{frame}


\begin{frame}[fragile]
	\frametitle{Referenzen}
	\begin{lstlisting}
    Person a = new Person();
	Person b = new Person();
	System.out.println(a == b);
	\end{lstlisting}
	Wird true oder false ausgegeben?
\end{frame}

\begin{frame}[fragile]
	\frametitle{Referenzen}
	\begin{lstlisting}
	Person a = new Person();
	Person b = new Person();
    System.out.println(a == b);
	\end{lstlisting}
	Wird true oder false ausgegeben?
	\newline
	$\rightarrow$ Es wird false ausgegeben
	\begin{lstlisting}
	System.out.println(a);        //Person@7ad041f3
	System.out.println(b);        //Person@251a69d7 	
	\end{lstlisting}
\end{frame}



\begin{frame}{Heap 01}
	\begin{minipage}{0.2\textwidth}
		
	\end{minipage}
	
	\hfill
	\begin{minipage}{0.5\textwidth} \vspace{-0.5cm}  \hspace{-4cm}
		\includegraphics[height=0.8\textheight]{images/heap_02.png}
	\end{minipage}
	
	\note{
		
	}
\end{frame}

\begin{frame}{Heap 02}
	\begin{minipage}{0.2\textwidth}
		
        \small
        \begin{itemize}
		    \item Durch Aufruf des Konstruktors wird ein neues Objekt auf dem Heap erzeugt
		\end{itemize}
	\end{minipage}
	
	\hfill
	\begin{minipage}{0.5\textwidth} \vspace{-2.0cm}  \hspace{-4cm}
		\includegraphics[height=0.8\textheight]{images/heap_03.png}
	\end{minipage}
	
	\note{
		
	}
\end{frame}

\begin{frame}{Heap 03}
	\begin{minipage}{0.2\textwidth}
		   \small
        \begin{itemize}
		    \item Gilt auch für Objekte in einem Objekt
            \item Jede Zuweisung gibt nur die Referenz auf das Objekt weiter!
		\end{itemize}
	\end{minipage}
	
	\hfill
	\begin{minipage}{0.5\textwidth} \vspace{-3.0cm}  \hspace{-4cm}
		\includegraphics[height=0.8\textheight]{images/heap_04.png}
	\end{minipage}
	
	\note{
		
	}
\end{frame}

\begin{frame}{Heap 04}
	\begin{minipage}{0.2\textwidth}
    
		\begin{itemize}
			\item Shallow Copy:\\
            \begin{small}
			Wenn das Objekt kopiert wird, werden nur Referenzen auf andere Objekte kopiert
            \end{small}
            \\[0.5 cm]
			\item Deep Copy:\\
              \begin{small}
			Die Objekte im Objekt sind echte Kopien
            \end{small}
		\end{itemize} 
	\end{minipage}
	
	\hfill
	\begin{minipage}{0.5\textwidth} \vspace{-5.5cm}  \hspace{-4cm}
		\includegraphics[height=0.8\textheight]{images/heap_05.png}
	\end{minipage}
	
	\note{
		
	}
\end{frame}



\subsection{Rekursion}
\begin{frame}[fragile]
	\frametitle{Rekursion}
	Was ist Rekursion?
	\begin{itemize}
		\item Methode, die sich selbt aufruft
		\item benötigt Rekursionsanker
		\item wenig code, jedoch häufig verwirrend
	\end{itemize}
\begin{lstlisting}
    public static void recursiveCount(int n){
        System.out.println(n);
        if( n <= 0){
            return;
        }
        recursiveCount(n-1);
    }
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Rekusion}
	Warum benutzen wir also nicht einfach immer Rekusion?
	\begin{itemize}
		\item für jeden Methoden Aufruf legen wir einen \textit{Stackframe} auf den Stack (Rücksprungadresse und alle lokalen variablen)
		\item Stack wird somit schnell gefüllt $\rightarrow$ \textit{Stack-Overflow}
		\item Durch \textit{Overhead} häufig langsamer
	\end{itemize}
	Also ist Rekusion schlecht?
	\begin{itemize}
		\item Nein, es gibt Programmiersprachen die darauf ausgelegt sind (Prolog)
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Aufgaben Rekursion}
	Lösen Sie folgende Aufgaben Rekursiv:
	\begin{itemize}
		\item Fakultätsberechnung
		\item Fibonacci-Folge
	\end{itemize}
\end{frame}

\section{Mini-Game}
\begin{frame}[fragile]
	\frametitle{Mini-Game}
	Entwickeln sie ihr Game weiter:
	\begin{enumerate}
		\item Erstellen sie eine Klasse \textit{Item}, welches einen Namen und eine Anzahl hat (Überlegen sie was sinnvoll ist, vielleicht toString() Methode überschreiben?)
		\item Ihr Inventar soll nun Item-Objekte Speichern
		\item passen sie die einzelnen Funktionen an (\textit{add}, \textit{find},\textit{use}), sodass diese mit Item-Objekten funktionieren
		\item werden sie kreativ
	\end{enumerate}
\end{frame}